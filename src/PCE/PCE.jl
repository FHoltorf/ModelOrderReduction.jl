using PolyChaos, Symbolics, ModelingToolkit, LinearAlgebra

export PCE, SparsePCE, moment_equations, pce_galerkin

include("PCE_utils.jl")

abstract type AbstractPCE end

struct PCE <: AbstractPCE
    states::Any # states
    parameters::Any # vector of parameters being expanded
    bases::Any # vector of pairs: p (symbolic variable) => polynomial basis (PolyChaos)
    bases_dict::Any # dictionary generated from bases
    sym_basis::Any # vector of basis functions (symbolic variables) !![indexing as generated by PolyChaos]!!
    pc_basis::Any # polychaos basis object 
    sym_to_pc::Any # dictionary mapping symbolic to pc basis 
    pc_to_sym::Any # dictionary mapping pc to symbolic basis 
    ansatz::Any # vector of pairs: x(t,p) => ∑ᵢ cᵢ(t)ξᵢ(p)
    moments::Any # matrix (?) of symbolic variables: cᵢ(t)
end
function PCE(states, bases::AbstractVector{<:Pair})
    # to deal with symbolic arrays
    states = collect(states)

    bases_dict = Dict(bases)
    parameters = [p for (p, op) in bases]
    ops = [op for (p, op) in bases]
    degs = [deg(op) for op in ops]
    min_deg = minimum(degs)
    if !(all(isequal(first(degs)), degs)) # allequal
        @warn "Currently only bases with identical degrees are supported." *
              "\nProceed with minimum common degree = $min_deg"
    end
    pc_basis = MultiOrthoPoly(ops, min_deg)
    n_basis = size(pc_basis.ind, 1)
    n_states = length(states)

    @variables ζ(parameters...)[1:n_basis]
    sym_basis = collect(ζ)

    sym_to_pc = Dict(ζ[i] => i for i in eachindex(ζ))
    pc_to_sym = Dict(pc_basis.ind[i,:] => ζ[i] for i in eachindex(ζ))

    moments = []
    for (i, state) in enumerate(collect(states))
        moment_name = Symbol("z" * Symbolics.map_subscripts(i))
        ind_vars = get_independent_vars(state)
        if isempty(ind_vars)
            pce_coeffs = @variables $(moment_name)[1:n_basis]
        else
            pce_coeffs = @variables $(moment_name)(ind_vars...)[1:n_basis]
        end
        push!(moments, collect(pce_coeffs[1]))
    end
    ansatz = [states[i] => sum(moments[i][j] * sym_basis[j] for j in 1:n_basis)
              for i in 1:n_states]
    return PCE(states, parameters, bases, bases_dict, sym_basis, pc_basis, sym_to_pc,
               pc_to_sym, ansatz, moments)
end
function (pce::PCE)(moment_vals, parameter_vals::AbstractMatrix)
    # wasteful => should implement my own version of this
    # this evaluates each polynomial via recurrence relation from scratch
    # can reuse many results. 
    # fine for now. 
    basis = evaluate(parameter_vals, pce.pc_basis)
    return [dot(moments, basis) for moments in moment_vals]
end
function (pce::PCE)(moment_vals, parameter_vals::AbstractVector)
    return pce(moment_vals, reshape(parameter_vals, 1, length(parameter_vals)))
end
function (pce::PCE)(moment_vals, parameter_vals::Number)
    return pce(moment_vals, reshape([parameter_vals], 1, 1))
end

struct SparsePCE <: AbstractPCE
    states::Any # states
    parameters::Any # vector of parameters being expanded
    bases::Any # vector of pairs: p (symbolic variable) => polynomial basis (PolyChaos)
    bases_dict::Any # dictionary generated from bases
    sparse_sym_basis::Any # vector of basis fxs for each state (as symbolic variable)
    sparse_pc_basis::Any # vector of basis fxs for each state (as multi-index)
    sym_basis::Any # vector of symbolic variables
    pc_basis::Any # dense multivariate polynomial
    sym_to_pc::Any # symbolic variable => linear index corresponding to multi-index in pc_basis
    pc_to_sym::Any # multi-index (0-indexed) => symboic variable
    pc_indices::Any # ordered set of linear indices corresponding to multi-indices in pc_basis
    state_pc_indices::Any # vector of incidence vectors for which basis functions are part of a state's pce ansatz
    ansatz::Any # vector of pairs: x(t,p) => ∑ᵢ cᵢ(t)ξᵢ(p)
    moments::Any # matrix (?) of symbolic variables: cᵢ(t)
end
function SparsePCE(sparse_states::AbstractVector{<:Pair}, bases::AbstractVector{<:Pair})
    bases_dict = Dict(bases)
    parameters = [p for (p, op) in bases]
    max_deg = maximum([deg(op) for (p,op) in bases])
    ops = [deg(op) < max_deg ? bump_degree(op, max_deg) : op for (p, op) in bases]
    
    pc_basis = MultiOrthoPoly(ops, max_deg)

    states = [state for (state, baxels) in sparse_states]
    sparse_pc_basis = [baxel for (state, baxel) in sparse_states]
    basis_fxns = union(sparse_pc_basis...)
    
    n_basis = length(basis_fxns)
    @variables ζ(parameters...)[1:n_basis]
    sym_basis = collect(ζ)

    pc_to_sym = Dict(basis_fxns[i] => sym_basis[i] for i in eachindex(basis_fxns))
    sym_to_pc = Dict(sym_basis[i] => find_multi_index(basis_fxns[i], pc_basis) for i in eachindex(basis_fxns))

    sparse_sym_basis = []
    moments = []
    for (i, (state, baxels)) in enumerate(sparse_states)
        push!(sparse_sym_basis, [pc_to_sym[baxel] for baxel in baxels])
        moment_name = "z" * Symbolics.map_subscripts(i)
        ind_vars = get_independent_vars(state)
        sub_moments = []
        for baxel in sparse_sym_basis[i]
            k = get_basis_indices(baxel) .+ 1
            submoment_name = Symbol(moment_name * Symbolics.map_subscripts(k...))
            if isempty(ind_vars)
                pce_coeff = @variables $(submoment_name)
            else
                pce_coeff = @variables $(submoment_name)(ind_vars...)
            end
            push!(sub_moments, pce_coeff[1])
        end
        push!(moments, sub_moments)
    end
    pc_indices = [sym_to_pc[sym_basis[i]] for i in eachindex(sym_basis)]
    pc_dict = Dict(pc_indices[i] => i for i in eachindex(pc_indices))
    state_pc_idcs = [zeros(Int, n_basis) for i in eachindex(states)]
    for k in eachindex(states) 
        idcs = [sym_to_pc[baxel] for baxel in sparse_sym_basis[k]]
        state_pc_idcs[k][[pc_dict[idx] for idx in idcs]] .= 1 
    end

    ansatz = [states[i] => sum(moments[i][j] * sparse_sym_basis[i][j] for j in eachindex(moments[i]))
              for i in eachindex(states)]
    return SparsePCE(states, parameters, bases, bases_dict,
                     sparse_sym_basis, sparse_pc_basis,
                     sym_basis, pc_basis, 
                     sym_to_pc, pc_to_sym, 
                     pc_indices, state_pc_idcs, 
                     ansatz, moments)
end
function (pce::SparsePCE)(moment_vals, parameter_vals::AbstractMatrix)
    # wasteful => should implement my own version of this
    # this evaluates each polynomial via recurrence relation from scratch
    # can reuse many results. 
    # fine for now. 
    #basis = evaluate(pce.pc_indices, parameter_vals, pce.pc_basis)
    #return [dot(moment_vals[k],basis[pce.state_pc_indices[k]]) for k in eachindex(moment_vals)]
    val = zeros(length(pce.states))
    for k in eachindex(pce.states)
        idcs = reduce(vcat,pce.sparse_pc_basis[k]')
        basis = evaluate(idcs, parameter_vals, pce.pc_basis)
        val[k] = dot(moment_vals[k], basis)
    end
    return val
end
function (pce::SparsePCE)(moment_vals, parameter_vals::AbstractVector)
    return pce(moment_vals, reshape(parameter_vals, 1, length(parameter_vals)))
end
function (pce::SparsePCE)(moment_vals, parameter_vals::Number)
    return pce(moment_vals, reshape([parameter_vals], 1, 1))
end

# 1. apply PCE ansatz
function generate_parameter_pce(pce::AbstractPCE)
    par_dim = length(pce.parameters)
    par_pce = Vector{Pair{eltype(pce.parameters), eltype(pce.sym_basis)}}(undef, par_dim)
    for (i, bases) in enumerate(pce.bases)
        p, op = bases
        par_pce[i] = p => pce.sym_basis[i + 1] + op.α[1]
    end
    return par_pce
end
function substitute_parameters(eqs::AbstractVector, pce::AbstractPCE)
    par_pce = generate_parameter_pce(pce)
    subs_eqs = [substitute(eq, par_pce) for eq in eqs]
    return subs_eqs
end
function substitute_pce_ansatz(eqs::AbstractVector, pce::AbstractPCE)
    subs_eqs = [expand(expand(substitute(eq, pce.ansatz))) for eq in eqs]
    return subs_eqs
end
function apply_ansatz(eqs::AbstractVector, pce::AbstractPCE)
    return substitute_pce_ansatz(substitute_parameters(eqs, pce), pce)
end

# 2. extract PCE expansion coeffs 
function extract_basismonomial_coeffs(eqs::AbstractVector, pce::PCE)
    basismonomial_coeffs = [extract_coeffs(eq, pce.sym_basis) for eq in eqs]
    basismonomial_indices = []
    for coeffs in basismonomial_coeffs
        union!(basismonomial_indices,
               [mono => get_basis_indices(mono) for mono in keys(coeffs)])
    end
    return basismonomial_coeffs, basismonomial_indices
end

function extract_basismonomial_coeffs(eqs::AbstractVector, pce::SparsePCE)
    basismonomial_coeffs = [extract_coeffs(eq, pce.sym_basis) for eq in eqs]
    basismonomial_indices = []
    for coeffs in basismonomial_coeffs
        temp = [mono => pce.pc_indices[get_basis_indices(mono) .+ 1] for mono in keys(coeffs)]
        union!(basismonomial_indices, temp)
    end
    return basismonomial_coeffs, basismonomial_indices
end

# 3. compute inner products
function maximum_degree(mono_indices::AbstractVector, pce::AbstractPCE)
    max_degree = 0
    for (mono, ind) in mono_indices
        println(ind)
        max_degree = max(max_degree,
                         maximum(sum(pce.pc_basis.ind[ind[i]+1, :]
                                     for i in eachindex(ind))))
    end
    return max_degree
end
function eval_scalar_products(mono_indices, pce::PCE)
    max_degree = maximum_degree(mono_indices, pce)
    degree_quadrature = max(ceil(Int, 0.5 * (max_degree + deg(pce.pc_basis) + 1)),
                            deg(pce.pc_basis))
    integrator_pce = bump_degree(pce.pc_basis, degree_quadrature)

    scalar_products = Dict()
    for k in 1:dim(pce.pc_basis)
        scalar_products[k] = Dict(mono => computeSP(vcat(ind, k - 1), integrator_pce)
                                  for (mono, ind) in mono_indices)
    end
    return scalar_products
end

function eval_scalar_products(mono_indices, pce::SparsePCE)
    max_degree = maximum_degree(mono_indices, pce)
    degree_quadrature = max(ceil(Int, 0.5 * (max_degree + deg(pce.pc_basis) + 1)),
                            deg(pce.pc_basis))
    integrator_pce = bump_degree(pce.pc_basis, degree_quadrature)

    scalar_products = Dict()
    for k in pce.pc_indices
        scalar_products[k] = Dict(mono => computeSP(vcat(ind, kpc - 1), integrator_pce)
                                  for (mono, ind) in mono_indices)
    end
    return scalar_products
end

# 4. Galerkin projection
function galerkin_projection(bm_coeffs, scalar_products, pce::PCE)
    projected_eqs = []
    scaling = computeSP2(pce.pc_basis)
    for i in eachindex(bm_coeffs)
        eqs = []
        for k in 1:dim(pce.pc_basis)
            push!(eqs,
                  1/scaling[k] * sum(bm_coeffs[i][mono] * scalar_products[k][mono]
                      for mono in keys(bm_coeffs[i])))
        end
        push!(projected_eqs, eqs)
    end
    return projected_eqs
end

function galerkin_projection(bm_coeffs, scalar_products, pce::SparsePCE)
    projected_eqs = []
    for i in eachindex(bm_coeffs)
        eqs = []
        for k in pce.sparse_pc_basis[i]
            scaling = computeSP(vcat(k,k), pce.pc_basis)
            push!(eqs,
                  1/scaling * sum(bm_coeffs[i][mono] * scalar_products[k][mono]
                      for mono in keys(bm_coeffs[i])))
        end
        push!(projected_eqs, eqs)
    end
    return projected_eqs
end

# 5. combine everything
function pce_galerkin(eqs::AbstractVector, pce::AbstractPCE)
    expanded_eqs = apply_ansatz(eqs, pce)
    basismono_coeffs, basismono_idcs = extract_basismonomial_coeffs(expanded_eqs, pce)
    scalar_products = eval_scalar_products(basismono_idcs, pce)
    projected_eqs = galerkin_projection(basismono_coeffs, scalar_products, pce)
    return projected_eqs
end

# 6. high-level interface
# 6a. apply pce to explicit ODE
function moment_equations(sys::ODESystem, pce::AbstractPCE)
    eqs = [eq.rhs for eq in equations(sys)]
    moment_eqs = reduce(vcat, pce_galerkin(eqs, pce))
   
    iv = independent_variable(sys)
    params = setdiff(parameters(sys), pce.parameters)
    D = Differential(iv)
    moments = reduce(vcat, pce.moments)
    name = Symbol(String(nameof(sys)) * "_pce")
    pce_system = ODESystem([D(moments[i]) ~ moment_eqs[i] for i in eachindex(moments)],
                           iv, moments, params, name = name)

    n_moments = dim(pce.pc_basis)
    n_states = length(states(sys))
    pce_eval = function (moment_vals, parameter_values)
        shape_state = [moment_vals[(i * n_moments + 1):((i + 1) * n_moments)]
                       for i in 0:(n_states - 1)]
        return pce(shape_state, parameter_values)
    end
    return pce_system, pce_eval
end

# 6b. apply pce to implicit & mass-matrix ODE/DAEs

# 6c. apply pce to algebraic equations

# 6d. apply pce to control problems

# 6e. ? 

# ToDo:
# better support to evaluate the PCE
# in particular => make evaluation of means, variances, etc evaluable from the object itself upon specification of the moment values
# hinderance -> how do you provide the moments in a convenient format?
